#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int seojam = 0, check = 0, from_idx = 0, to_idx = 0;
int from_print[1023] = { 0 };
int to_print[1023] = { 0 };

void set(int* lss, int count, int num) {
    for (int i = 0; i < count; i++) {
        scanf("%d", &lss[i]);
    }
    for (int i = count; i < num; i++) {
        lss[i] = 0;
    }
}

void print_tower(int* lss, int num) {
    for (int i = 0; i < num; i++) {
        printf("%d ", lss[i]);
    }
    printf("\n");
}

typedef struct {
    int* lss;
    int number;
    int is_this;
} S;

int isSame(int num, S firstA, S secondA, S thirdA, S firstB, S secondB, S thirdB) {
    for (int i = 0; i < num; i++) {
        if (firstA.lss[i] != firstB.lss[i]) {
            return 0;
        }
        else if (secondA.lss[i] != secondB.lss[i]) {
            return 0;
        }
        else if (thirdA.lss[i] != thirdB.lss[i]) {
            return 0;
        }
    }
    return 1;
}

void orignal_hanoi(int num, S* from, S* tmp, S* to, int check) {
    if (num == 1) {
        from->lss[--from->number] = 0;
        to->lss[to->number++] = 1;
        seojam++;
        if (check) {
            if (from->is_this == 1 && to->is_this == 2) {
                from_print[from_idx++] = 1;
                to_print[to_idx++] = 2;
                // printf("1 2 \n");
            }
            else if (from->is_this == 1) {
                from_print[from_idx++] = 1;
                to_print[to_idx++] = 3;
                // printf("1 3 \n");
            }
            else if (from->is_this == 2 && to->is_this == 1) {
                from_print[from_idx++] = 2;
                to_print[to_idx++] = 1;
                // printf("2 1 \n");
            }
            else if (from->is_this == 2) {
                from_print[from_idx++] = 2;
                to_print[to_idx++] = 3;
                // printf("2 3 \n");
            }
            else if (from->is_this == 3 && to->is_this == 1) {
                from_print[from_idx++] = 3;
                to_print[to_idx++] = 1;
                // printf("3 1 \n");
            }
            else {
                from_print[from_idx++] = 3;
                to_print[to_idx++] = 2;
                // printf("3 2 \n");
            }
        }
    }
    else {
        orignal_hanoi(num - 1, from, to, tmp, check);
        from->lss[--from->number] = 0;
        to->lss[to->number++] = num;
        seojam++;
        if (check) {
            if (from->is_this == 1 && to->is_this == 2) {
                from_print[from_idx++] = 1;
                to_print[to_idx++] = 2;
                // printf("1 2 \n");
            }
            else if (from->is_this == 1) {
                from_print[from_idx++] = 1;
                to_print[to_idx++] = 3;
                // printf("1 3 \n");
            }
            else if (from->is_this == 2 && to->is_this == 1) {
                from_print[from_idx++] = 2;
                to_print[to_idx++] = 1;
                // printf("2 1 \n");
            }
            else if (from->is_this == 2) {
                from_print[from_idx++] = 2;
                to_print[to_idx++] = 3;
                // printf("2 3 \n");
            }
            else if (from->is_this == 3 && to->is_this == 1) {
                from_print[from_idx++] = 3;
                to_print[to_idx++] = 1;
                // printf("3 1 \n");
            }
            else {
                from_print[from_idx++] = 3;
                to_print[to_idx++] = 2;
                // printf("3 2 \n");
            }
        }
        orignal_hanoi(num - 1, tmp, from, to, check);
    }
}

void hanoi(int num, S* from, S* tmp, S* to, int now, int next, int* now_where, int max, int check) {
    if (num == 1) {
        if (now != next) {
            if (now == 1 && next == 2) {
                from->lss[--from->number] = 0;
                tmp->lss[tmp->number++] = 1;
                now_where[num - 1] = 2;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 1;
                    to_print[to_idx++] = 2;
                    // printf("1 2 \n");
                }
            }
            else if (now == 1) {
                from->lss[--from->number] = 0;
                to->lss[to->number++] = 1;
                now_where[num - 1] = 3;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 1;
                    to_print[to_idx++] = 3;
                    // printf("1 3 \n");
                }
            }
            else if (now == 2 && next == 1) {
                tmp->lss[--tmp->number] = 0;
                from->lss[from->number++] = 1;
                now_where[num - 1] = 1;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 2;
                    to_print[to_idx++] = 1;
                    // printf("2 1 \n");
                }
            }
            else if (now == 2) {
                tmp->lss[--tmp->number] = 0;
                to->lss[to->number++] = 1;
                now_where[num - 1] = 3;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 2;
                    to_print[to_idx++] = 3;
                    // printf("2 3 \n");
                }
            }
            else if (now == 3 && next == 1) {
                to->lss[--to->number] = 0;
                from->lss[from->number++] = 1;
                now_where[num - 1] = 1;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 3;
                    to_print[to_idx++] = 1;
                    // printf("3 1 \n");
                }
            }
            else if (now == 3) {
                to->lss[--to->number] = 0;
                tmp->lss[tmp->number++] = 1;
                now_where[num - 1] = 2;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 3;
                    to_print[to_idx++] = 2;
                    // printf("3 2 \n");
                }
            }
        }
        // 1이 아닐 때 순환
    }
    else {
        if (now != next) {
            if (now == 1 && next == 2) {
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 3, now_where, max, check);

                from->lss[--from->number] = 0;
                tmp->lss[tmp->number++] = num;
                now_where[num - 1] = 2;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 1;
                    to_print[to_idx++] = 2;
                    // printf("1 2 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, to, from, tmp, check);
            }
            else if (now == 1) {
                // 다음 수를 2으로 이동
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 2, now_where, max, check);

                from->lss[--from->number] = 0;
                to->lss[to->number++] = num;
                now_where[num - 1] = 3;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 1;
                    to_print[to_idx++] = 3;
                    // printf("1 3 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, tmp, from, to, check);
            }
            else if (now == 2 && next == 1) {
                // 다음 수를 3으로 이동
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 3, now_where, max, check);

                tmp->lss[--tmp->number] = 0;
                from->lss[from->number++] = num;
                now_where[num - 1] = 1;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 2;
                    to_print[to_idx++] = 1;
                    // printf("2 1 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, to, tmp, from, check);
            }
            else if (now == 2) {
                // 다음 수를 1로 이동
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 1, now_where, max, check);

                tmp->lss[--tmp->number] = 0;
                to->lss[to->number++] = num;
                now_where[num - 1] = 3;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 2;
                    to_print[to_idx++] = 3;
                    // printf("2 3 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, from, tmp, to, check);
            }
            else if (now == 3 && next == 1) {
                // 다음 수를 2로 이동
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 2, now_where, max, check);

                to->lss[--to->number] = 0;
                from->lss[from->number++] = num;
                now_where[num - 1] = 1;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 3;
                    to_print[to_idx++] = 1;
                    // printf("3 1 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, tmp, to, from, check);
            }
            else if (now == 3) {
                // 다음 수를 1로 이동
                hanoi(num - 1, from, tmp, to, now_where[num - 2], 1, now_where, max, check);

                to->lss[--to->number] = 0;
                tmp->lss[tmp->number++] = num;
                now_where[num - 1] = 2;
                seojam++;
                if (check) {
                    from_print[from_idx++] = 3;
                    to_print[to_idx++] = 2;
                    // printf("3 2 \n");
                }

                if (num - 1 != max - 1) orignal_hanoi(num - 1, from, to, tmp, check);
            }
        }
        else {
            if (now == 1) {
                // 다음 수를 1로 이동
                if (num - 1 != max - 1) hanoi(num - 1, from, tmp, to, now_where[num - 2], 1, now_where, max, check);

            }
            else if (now == 2) {
                // 다음 수를 2로 이동
                if (num - 1 != max - 1) hanoi(num - 1, from, tmp, to, now_where[num - 2], 2, now_where, max, check);

            }
            else if (now == 3) {
                // 다음 수를 3으로 이동
                if (num - 1 != max - 1) hanoi(num - 1, from, tmp, to, now_where[num - 2], 3, now_where, max, check);
            }
        }
    }
}

int main(void) {
    int num, count;
    scanf("%d", &num);
    if (num <= 10) {
        check = 1;
    }

    S first, second, third, first_final, second_final, third_final;
    first.lss = (int*)malloc(sizeof(int) * num);
    second.lss = (int*)malloc(sizeof(int) * num);
    third.lss = (int*)malloc(sizeof(int) * num);
    first_final.lss = (int*)malloc(sizeof(int) * num);
    second_final.lss = (int*)malloc(sizeof(int) * num);
    third_final.lss = (int*)malloc(sizeof(int) * num);

    // 초기 상태
    scanf("%d", &count);
    first.number = count;
    set(first.lss, count, num);
    first.is_this = 1;

    scanf("%d", &count);
    second.number = count;
    set(second.lss, count, num);
    second.is_this = 2;

    scanf("%d", &count);
    third.number = count;
    set(third.lss, count, num);
    third.is_this = 3;

    // 최종 상태
    scanf("%d", &count);
    first_final.number = count;
    set(first_final.lss, count, num);

    scanf("%d", &count);
    second_final.number = count;
    set(second_final.lss, count, num);

    scanf("%d", &count);
    third_final.number = count;
    set(third_final.lss, count, num);

    // 초기 상태의 원판들이 1번, 2번, 3번 어디에 위치하는지 (1원판은 0인덱스에 위치 저장, ...)
    int* set_where = (int*)malloc(sizeof(int) * num);
    int* final_where = (int*)malloc(sizeof(int) * num);

    for (int i = 0; i < first_final.number; i++) {
        final_where[first_final.lss[i] - 1] = 1;
    }
    for (int i = 0; i < second_final.number; i++) {
        final_where[second_final.lss[i] - 1] = 2;
    }
    for (int i = 0; i < third_final.number; i++) {
        final_where[third_final.lss[i] - 1] = 3;
    }

    for (int i = num; i >= 1; i--) {
        for (int j = 0; j < first.number; j++) {
            set_where[first.lss[j] - 1] = 1;
        }
        for (int j = 0; j < second.number; j++) {
            set_where[second.lss[j] - 1] = 2;
        }
        for (int j = 0; j < third.number; j++) {
            set_where[third.lss[j] - 1] = 3;
        }
        hanoi(i, &first, &second, &third, set_where[i - 1], final_where[i - 1], set_where, i, check);
    }

    printf("%d \n", seojam);
    if (check) {
        for (int i = 0; i < from_idx; i++) {
            printf("%d %d \n", from_print[i], to_print[i]);
        }
    }

    free(first.lss);
    free(second.lss);
    free(third.lss);
    free(first_final.lss);
    free(second_final.lss);
    free(third_final.lss);
    free(set_where);
    free(final_where);

    return 0;
}
